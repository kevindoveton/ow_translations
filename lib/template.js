"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fileForTranslations = fileForTranslations;

var _parser = require("./parser");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function getTemplateStrings(translations) {
  delete translations['language'];
  delete translations['region'];
  var rows = Object.keys(translations).map(function (key) {
    var _translations$key = _slicedToArray(translations[key], 2),
        value = _translations$key[0],
        type = _translations$key[1];

    if (type === _parser.TranslationRowType.function) {
      //No need for quotes for function based rows
      return "    ".concat(key, ": ").concat(value, ",");
    }

    return "    ".concat(key, ": \"").concat(value, "\",");
  });
  return rows.reduce(function (acc, curr) {
    return acc + '\n' + curr;
  }, '');
}

function fileForTranslations(translationEnum, translations) {
  var templateStrings = "hello 123";
  var string = "/**\n * Do not edit this file directly. \n * Instead, edit the appropriate spreadsheet \n * https://docs.google.com/spreadsheets/d/102zLqEWj4xlqqNgVUFCiMLqdcvaLY6GntS1xmlHdAE8/edit#gid=0\n * and recompile in order to change these fields\n */\n\nimport { TranslationFile } from \"../Types\";\n\nconst ".concat(translationEnum, ": TranslationFile = {\n  metadata: {\n    language: '").concat(translations.language[0], "',\n    region: '").concat(translations.region[0], "',\n  },\n  templates: {").concat(getTemplateStrings(translations), "\n  }\n}\n\nexport {").concat(translationEnum, "};\n");
  return string;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90ZW1wbGF0ZS50cyJdLCJuYW1lcyI6WyJnZXRUZW1wbGF0ZVN0cmluZ3MiLCJ0cmFuc2xhdGlvbnMiLCJyb3dzIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsImtleSIsInZhbHVlIiwidHlwZSIsIlRyYW5zbGF0aW9uUm93VHlwZSIsImZ1bmN0aW9uIiwicmVkdWNlIiwiYWNjIiwiY3VyciIsImZpbGVGb3JUcmFuc2xhdGlvbnMiLCJ0cmFuc2xhdGlvbkVudW0iLCJ0ZW1wbGF0ZVN0cmluZ3MiLCJzdHJpbmciLCJsYW5ndWFnZSIsInJlZ2lvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0FBSUEsU0FBU0Esa0JBQVQsQ0FBNEJDLFlBQTVCLEVBQXFHO0FBQ25HLFNBQU9BLFlBQVksQ0FBQyxVQUFELENBQW5CO0FBQ0EsU0FBT0EsWUFBWSxDQUFDLFFBQUQsQ0FBbkI7QUFHQSxNQUFNQyxJQUFJLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSCxZQUFaLEVBQTBCSSxHQUExQixDQUE4QixVQUFBQyxHQUFHLEVBQUk7QUFBQSwyQ0FDMUJMLFlBQVksQ0FBQ0ssR0FBRCxDQURjO0FBQUEsUUFDekNDLEtBRHlDO0FBQUEsUUFDbENDLElBRGtDOztBQUVoRCxRQUFJQSxJQUFJLEtBQUtDLDJCQUFtQkMsUUFBaEMsRUFBMEM7QUFDeEM7QUFDQSwyQkFBY0osR0FBZCxlQUFzQkMsS0FBdEI7QUFDRDs7QUFDRCx5QkFBY0QsR0FBZCxpQkFBdUJDLEtBQXZCO0FBQ0QsR0FQWSxDQUFiO0FBUUEsU0FBT0wsSUFBSSxDQUFDUyxNQUFMLENBQVksVUFBQ0MsR0FBRCxFQUFjQyxJQUFkLEVBQStCO0FBQ2hELFdBQU9ELEdBQUcsR0FBRyxJQUFOLEdBQWFDLElBQXBCO0FBQ0QsR0FGTSxFQUVMLEVBRkssQ0FBUDtBQUdEOztBQUVNLFNBQVNDLG1CQUFULENBQTZCQyxlQUE3QixFQUErRGQsWUFBL0QsRUFBdUk7QUFFNUksTUFBTWUsZUFBZSxHQUFHLFdBQXhCO0FBRUEsTUFBTUMsTUFBTSx5VEFTTkYsZUFUTSxrRUFXR2QsWUFBWSxDQUFDaUIsUUFBYixDQUFzQixDQUF0QixDQVhILDhCQVlDakIsWUFBWSxDQUFDa0IsTUFBYixDQUFvQixDQUFwQixDQVpELHFDQWNFbkIsa0JBQWtCLENBQUNDLFlBQUQsQ0FkcEIsaUNBa0JKYyxlQWxCSSxTQUFaO0FBcUJBLFNBQU9FLE1BQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zbGF0aW9uUm93VHlwZSB9IGZyb20gXCIuL3BhcnNlclwiO1xuaW1wb3J0IHsgVHJhbnNsYXRpb25FbnVtIH0gZnJvbSBcIi4vVHlwZXNcIjtcblxuXG5mdW5jdGlvbiBnZXRUZW1wbGF0ZVN0cmluZ3ModHJhbnNsYXRpb25zOiB7IFtpbmRleDogc3RyaW5nXTogW3N0cmluZywgVHJhbnNsYXRpb25Sb3dUeXBlXSB9KTogc3RyaW5nIHtcbiAgZGVsZXRlIHRyYW5zbGF0aW9uc1snbGFuZ3VhZ2UnXTtcbiAgZGVsZXRlIHRyYW5zbGF0aW9uc1sncmVnaW9uJ107XG5cblxuICBjb25zdCByb3dzID0gT2JqZWN0LmtleXModHJhbnNsYXRpb25zKS5tYXAoa2V5ID0+IHtcbiAgICBjb25zdCBbdmFsdWUsIHR5cGVdID0gdHJhbnNsYXRpb25zW2tleV07XG4gICAgaWYgKHR5cGUgPT09IFRyYW5zbGF0aW9uUm93VHlwZS5mdW5jdGlvbikge1xuICAgICAgLy9ObyBuZWVkIGZvciBxdW90ZXMgZm9yIGZ1bmN0aW9uIGJhc2VkIHJvd3NcbiAgICAgIHJldHVybiBgICAgICR7a2V5fTogJHt2YWx1ZX0sYFxuICAgIH1cbiAgICByZXR1cm4gYCAgICAke2tleX06IFwiJHt2YWx1ZX1cIixgXG4gIH0pO1xuICByZXR1cm4gcm93cy5yZWR1Y2UoKGFjYzogc3RyaW5nLCBjdXJyOiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gYWNjICsgJ1xcbicgKyBjdXJyO1xuICB9LCcnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGVGb3JUcmFuc2xhdGlvbnModHJhbnNsYXRpb25FbnVtOiBUcmFuc2xhdGlvbkVudW0sIHRyYW5zbGF0aW9uczoge1tpbmRleDogc3RyaW5nXTogW3N0cmluZywgVHJhbnNsYXRpb25Sb3dUeXBlXX0gKTogc3RyaW5nIHtcblxuICBjb25zdCB0ZW1wbGF0ZVN0cmluZ3MgPSBcImhlbGxvIDEyM1wiO1xuXG4gIGNvbnN0IHN0cmluZyA9IGAvKipcbiAqIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBkaXJlY3RseS4gXG4gKiBJbnN0ZWFkLCBlZGl0IHRoZSBhcHByb3ByaWF0ZSBzcHJlYWRzaGVldCBcbiAqIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzEwMnpMcUVXajR4bHFxTmdWVUZDaU1McWRjdmFMWTZHbnRTMXhtbEhkQUU4L2VkaXQjZ2lkPTBcbiAqIGFuZCByZWNvbXBpbGUgaW4gb3JkZXIgdG8gY2hhbmdlIHRoZXNlIGZpZWxkc1xuICovXG5cbmltcG9ydCB7IFRyYW5zbGF0aW9uRmlsZSB9IGZyb20gXCIuLi9UeXBlc1wiO1xuXG5jb25zdCAke3RyYW5zbGF0aW9uRW51bX06IFRyYW5zbGF0aW9uRmlsZSA9IHtcbiAgbWV0YWRhdGE6IHtcbiAgICBsYW5ndWFnZTogJyR7dHJhbnNsYXRpb25zLmxhbmd1YWdlWzBdfScsXG4gICAgcmVnaW9uOiAnJHt0cmFuc2xhdGlvbnMucmVnaW9uWzBdfScsXG4gIH0sXG4gIHRlbXBsYXRlczogeyR7Z2V0VGVtcGxhdGVTdHJpbmdzKHRyYW5zbGF0aW9ucyl9XG4gIH1cbn1cblxuZXhwb3J0IHske3RyYW5zbGF0aW9uRW51bX19O1xuYFxuXG4gIHJldHVybiBzdHJpbmc7XG59Il19